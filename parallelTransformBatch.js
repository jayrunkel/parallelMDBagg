// ================================================================
// Installation instructions
// ================================================================
//
// 1. Install nodejs
// 2. Install required node modules
//
//    npm install mongodb
//    npm install async
//    npm install @supercharge/promise-pool
//
// ================================================================
// Execution Instructions
// ================================================================
//
// Run like:
// node parallelTransformBatch.js <dbUser> <dbPassword> <dbName> <clusterURI>
//
// Example:
// node parallelTransformBatch.js user password recommendations cluster0.gptft.mongodb.net



const { MongoClient, ObjectID, getTimestamp, ISODate} = require("mongodb");
const { async, parallel } = require('async');
const { PromisePool } = require('@supercharge/promise-pool');

const totalNumBlocks = 1000000;
const numThreads = 10;
const userName = process.argv[2];
const password = process.argv[3];

const extraCardColName = "xtra_card";
const skuColName = "xtra_card_sku_rank";
const mktColName = "xtra_card_mkt_sgmt";
const couponColName = "xtra_card_mfr_coupon_rank";


const outColName = "extra_card_full"; // target collection - the one generated by this script

//test cluster
//const dbName = "zoominfo";
//const clusterName = "demo.aamtz.mongodb.net";

//zoom info cluster
const dbName = process.argv[4];//"poc_test";
const clusterName = process.argv[5];//"fts-poc.zo7tx.mongodb.net";

const uri = `mongodb+srv://${userName}:${password}@${clusterName}?retryWrites=true&w=majority`;


Array.prototype.sortByProp = function(p){
  return this.sort(function(a,b){
    return (a[p] > b[p]) ? 1 : (a[p] < b[p]) ? -1 : 0;
  });
};


// ================================================================
// Required Indexes
// ================================================================
//
// company
//   {companyId: 1}


let equiJoin = [
//  {"$match" : {"$and": [{"XTRA_CARD_NBR": {"$gt": limits["min"]}},{"XTRA_CARD_NBR": {"$lte": limits["max"]}}]}},
//  {"$skip" : limits["skip"]},
//  {"$limit" : limits["limit"]},
  {"$lookup" : {
    "from": skuColName,   // join with xtra_card_sku_rank collection
    "localField": 'XTRA_CARD_NBR',
    "foreignField": 'XTRA_CARD_NBR',
    "pipeline" : [
      {"$project" : {"_id" : 0,"XTRA_CARD_NBR": 0}}
    ],
    "as": 'sku_rank'
  }},
  {"$lookup" : {
    "from": mktColName,						// join with xtra_card_mkt_sgmt
    "localField": 'XTRA_CARD_NBR',
    "foreignField": 'XTRA_CARD_NBR',
    "pipeline" : [
      {"$project" : {"_id" : 0,"XTRA_CARD_NBR": 0}},
      {"$limit" : 1}
    ],
    "as": 'mkt_sgmt'
  }},
  {"$unwind" : "$mkt_sgmt"},
  {"$lookup" : {
    "from": couponColName,				// join with xtra_card_mfr_coupon_rank
    "localField": 'XTRA_CARD_NBR',
    "foreignField": 'XTRA_CARD_NBR',
    "pipeline" : [
      {"$project" : {"_id" : 0,"XTRA_CARD_NBR": 0}},
      {"$limit" : 1}
    ],
    "as": 'mfr_coupon_rank'
  }},
	{
		$merge: {
			into: outColName,
			on: 'XTRA_CARD_NBR',
			whenMatched: 'replace',
			whenNotMatched: 'insert'
		}
	}
];



// Replace the uri string with your connection string.



const client = new MongoClient(uri);

async function run() {
  try {
		console.log(uri);
//    const database = client.db('zoominfo');
		const database = client.db(dbName);
		
    const sourceCol = database.collection(extraCardColName);
		try {
			await database.createCollection(outColName);
		} catch (err) {
			console.log("CREATE COLLECTION outColName: ", err);
		}
		const outCol = database.collection(outColName);
		await outCol.createIndex({XTRA_CARD_NBR : 1}, {unique: true});

		const minDoc = await sourceCol.find().sort({XTRA_CARD_NBR : 1}).limit(1).toArray();
		const maxDoc = await sourceCol.find().sort({XTRA_CARD_NBR : -1}).limit(1).toArray();
		
		const minDocValue = minDoc[0].XTRA_CARD_NBR;
		const maxDocValue = maxDoc[0].XTRA_CARD_NBR;
		const blockSize = Math.ceil((maxDocValue - minDocValue)/totalNumBlocks);

		console.log("================ Block Calculations ================");
		console.log(`[${extraCardColName} Collection _id Range] - Min: ${minDocValue}, Max: ${maxDocValue}`);
		console.log("Block Size: ", blockSize);
		
		let blockMin;
		let blockMax;

		let countParams = [];
		let processedBlocks = 0;


		async function countBlock(bId, lowerObjectId, upperObjectId) {
			console.log(`Queing Count[${bId}]: ${lowerObjectId} to ${upperObjectId}`);

			let matchStage = {
				$match : {XTRA_CARD_NBR: {$gte: lowerObjectId, $lte: upperObjectId}}
			};


			const count = await sourceCol.aggregate([matchStage].concat(equiJoin), {allowDiskUse: true}).toArray();
//			const count = await personCol.countDocuments();
			console.log(`Completed [${bId}]: ${lowerObjectId} to ${upperObjectId} Result: ${count}`);
			return {blockId: bId, lowerBound: lowerObjectId, upperBound: upperObjectId, result: count};
		}
		
		
		console.log("================ Building Agg Blocks ================");
		for (let i = 0; i < totalNumBlocks; i++) {
			blockMin = (i === 0) ? minDocValue : blockMax;
			blockMax = blockMin + blockSize;
			
			console.log(`Block${i} - Min: ${blockMin}, Max: ${blockMax}`);
			//const count = await personCol.countDocuments({_id: {$gte: lowerObjectId, $lte: upperObjectId}});
			//console.log(`Count: ${count}`);
			
			countParams.push({blockId: i, lower: blockMin, upper: blockMax});
		}


		console.log("================ Batch Processing Asynchronously ================");
		const {results, errors}  = await PromisePool
					.withConcurrency(numThreads)
					.for(countParams)
					.process(async block => {
						const result = await countBlock(block.blockId, block.lower, block.upper);
						return result;
					});

		console.log("================ PROCESSING COMPLETE ================");
		console.log("RESULTS: ");
		results.sortByProp('blockId').map(result => console.log(result));
		console.log("ERRORS: ");
		console.log(errors);
		
  } catch (err) {
		console.log("CAUGHT ERRORS: ");
		console.log(err)
		console.log("CURRENT RESULTS: ");
		results.sortByProp('blockId').map(result => console.log(result));
	}
	finally {
    // Ensures that the client will close when you finish/error
    await client.close();
  }
}
run().catch(console.dir);
